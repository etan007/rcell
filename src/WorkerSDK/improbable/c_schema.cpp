#include "WorkerSDK/improbable/c_schema.h"
#include "automaton/core/data/protobuf/protobuf_schema.h"
#include "automaton/core/data/protobuf/protobuf_msg.h"
#include "pb/dynamic_msg_mgr.h"
using automaton::core::data::protobuf::protobuf_schema;
using automaton::core::data::protobuf::protobuf_msg;
using automaton::core::data::schema;
using std::string;
 
struct pbs_ComponentData
{
   protobuf_schema* cs;
   int32_t  MsgComponentDataID;
   int32_t  MsgComponentDataFiledID;
};
struct pbs_Object
{
   protobuf_schema* cs;
   int32_t msg_obj_id;
};
 
 /**
  * Load a serialized schema bundle from a byte buffer. This byte buffer should contain a fully
  * loaded schema bundle generated by the schema compiler using the `--bundle_out` argument.
  *
  * Make sure to call `Schema_Bundle_GetError` after loading to check if there were any errors when
  * loading.
  */
 Schema_Bundle* Schema_Bundle_Load(const uint8_t* buffer, uint32_t length)
 {
  return nullptr;
 }
 /**
  * Returns a null-terminated string containing one or more error messages (separated by '\n') if any
  * errors were encountered when loading the schema bundle. Note that the string buffer returned is
  * stored inside the schema bundle, and therefore will be freed when the bundle is destroyed. Will
  * return NULL if there were no errors.
  */
const char* Schema_Bundle_GetError(const Schema_Bundle* bundle)
{
 return nullptr;
}
 /** Free the resources associated with a schema bundle. */
void Schema_Bundle_Destroy(Schema_Bundle* bundle)
{
 
}

 /** Allocate a generic data object (i.e. arbitrary schema object) type instance. */
Schema_GenericData* Schema_CreateGenericData(void)
{
 return nullptr;
}
 /** Performs a deep copy of the source generic data object and returns the new copy. */
Schema_GenericData* Schema_CopyGenericData(const Schema_GenericData* source)
{
 return nullptr;
}
 /** Free the resources associated with a generic data object type instance. */
void Schema_DestroyGenericData(Schema_GenericData* request)
 {
  
 }
 /** Get the generic data object as a Schema_Object. */
Schema_Object* Schema_GetGenericDataObject(Schema_GenericData* request)
 {
  return nullptr;
 }

 /** Allocate a command request schema type instance. */
Schema_CommandRequest* Schema_CreateCommandRequest(void)
 {
  return nullptr;
 }
 /** Performs a deep copy of the source command request and returns the new copy. */
Schema_CommandRequest* Schema_CopyCommandRequest(const Schema_CommandRequest* source)
 {
  return nullptr;
 }
 /** Free the resources associated with a command request schema type instance. */
void Schema_DestroyCommandRequest(Schema_CommandRequest* request)
 {
  
 }
 /** Get the command request as a Schema_Object. */
Schema_Object* Schema_GetCommandRequestObject(Schema_CommandRequest* request)
 {
  return nullptr;
 }

 /** Allocate a command response schema type instance. */
Schema_CommandResponse* Schema_CreateCommandResponse(void)
 {
  return nullptr;
 }
 /** Performs a deep copy of the source command response and returns the new copy. */
Schema_CommandResponse* Schema_CopyCommandResponse(const Schema_CommandResponse* source)
 {
  return nullptr;
 }
 /** Free the resources associated with a command response schema type instance. */
void Schema_DestroyCommandResponse(Schema_CommandResponse* response)
 {
  
 }
 /** Get the command response as a Schema_Object. */
Schema_Object* Schema_GetCommandResponseObject(Schema_CommandResponse* response)
 {
  return nullptr;
 }

 /** Allocate a component data snapshot schema type instance. */
Schema_ComponentData* Schema_CreateComponentData(uint32_t id)
 {
    auto msg_factory = dynamic_msg_mgr::getMe().get_factory();
    return (Schema_ComponentData*)msg_factory->new_message_by_compmentid(id).get();
  
 }
 /** Performs a deep copy of the source component data and returns the new copy. */
Schema_ComponentData* Schema_CopyComponentData(const Schema_ComponentData* source)
 {
   return nullptr;
 }
 /** Free the resources associated with a component data snapshot schema type instance. */
void Schema_DestroyComponentData(Schema_ComponentData* data)
 {
 
 }
 /** Get the component data snapshot as a Schema_Object. */
 Schema_Object* Schema_GetComponentDataFields(Schema_ComponentData* data)
 {
    return (Schema_Object*)data;
 }

 /** Allocate a component update schema type instance. */
Schema_ComponentUpdate* Schema_CreateComponentUpdate(void)
 {
  return  nullptr;
 }
 /** Performs a deep copy of the source component update and returns the new copy. */
Schema_ComponentUpdate* Schema_CopyComponentUpdate(const Schema_ComponentUpdate* source)
 {
  return nullptr;
 }
 /** Free the resources associated with a component update schema type instance. */
void Schema_DestroyComponentUpdate(Schema_ComponentUpdate* update)
 {
  
 }
 /**
  * Get an object representing the non-event fields in a component update. This object should be used
  * as if it had one field for each field in the component, whose type corresponds to the type of the
  * field as defined in schema. Note that when an option, list or map field in a component is set to
  * the empty value, it will not / should not appear here. Instead, use
  * Schema_IndexComponentUpdateClearedField and related functions.
  */
Schema_Object* Schema_GetComponentUpdateFields(Schema_ComponentUpdate* update)
 {
  return  nullptr;
 }
 /**
  * Get an object representing the event fields in a component update. This object should be used
  * as if it had one field for each event in the component. Each field behaves like a list (may have
  * multiple instances of the same event), and the field ID of an event is its 1-based position in
  * the order the events appear in the component in the schema.
  */
Schema_Object* Schema_GetComponentUpdateEvents(Schema_ComponentUpdate* update)
 {
  return nullptr;
 }
 /**
  * Clears the list of fields that this update sets to the empty value (for option, list and map
  * fields in a component).
  */
void Schema_ClearComponentUpdateClearedFields(Schema_ComponentUpdate* update)
 {
  
 }
 /**
  * Checks whether this updates sets an option, list of map field in a component to the empty value.
  */
uint8_t Schema_IsComponentUpdateFieldCleared(Schema_ComponentUpdate* update,Schema_FieldId field_id)
 {
  return 0;
 }
 /**
  * Specifies that this update sets an option, list or map field in a component to the empty
  * value.
  */
void Schema_AddComponentUpdateClearedField(Schema_ComponentUpdate* update,Schema_FieldId field_id)
 {
  
 }
 /**
  * Returns the number of option, list and map fields in a component that this update sets to the
  * empty value.
  */
uint32_t Schema_GetComponentUpdateClearedFieldCount(const Schema_ComponentUpdate* update)
 {
  return 0;
 }
 /**
  * Returns the field ID of an option, list or map field which is set to the empty value by this
  * update.
  */
Schema_FieldId Schema_IndexComponentUpdateClearedField(const Schema_ComponentUpdate* update, uint32_t index)
 {
  Schema_FieldId fid = 0;
  return fid;
 }
 /**
  * Returns all field IDs of option, list, or map fields which are set to the empty value by this
  * component. The output_array should have space for
  * Schema_GetComponentUpdateClearedFieldCount(update) field IDs.
  */
void Schema_GetComponentUpdateClearedFieldList(const Schema_ComponentUpdate* update,Schema_FieldId* output_array)
 {
  
 }

 /**
  * Merges a component update 'update' into an at-rest component data object 'target_data'. This is
  * semantically equivalent to a component update being "applied" to the at-rest component data.
  *
  * This function will mutate the component data object by appending the bytes representation of the
  * update to the end of the component data. This is efficient because if the component update is
  * small, it wouldn't need to reshuffle any fields under the hood, but will have unbounded memory
  * growth (proportional to the serialized component update after each function call).
  *
  * To avoid mutating the data and having unbounded memory growth, use this function in combination
  * with Schema_CopyComponentData to copy the component data first. Note that calling
  * Schema_CopyComponentData on a component data will only require storage for the serialized size of
  * the component data in the returned object, hence why memory growth is no longer unbounded when
  * this is used.
  *
  * Returns 1 if success, 0 if there was a failure. Call
  * `Schema_GetError(Schema_GetComponentDataFields(target_data))` to get the error message.
  */
uint8_t Schema_ApplyComponentUpdateToData(const Schema_ComponentUpdate* update,Schema_ComponentData* target_data)
 {
  return 0;
 }
 /**
  * Merges a component update 'update' into another component update object 'target_update'. This is
  * semantically equivalent to combining two component updates into a single component update such
  * that, when applied to some at-rest component data, it will be semantically equivalent to applying
  * 'target_update' followed by 'update'. 'target_update' will be mutated to contain the resulting
  * combined update.
  *
  * Unlike Schema_ApplyComponentUpdateToData, this function will not have unbounded memory growth. To
  * avoid mutating 'target_update', use this function in combination with Schema_CopyComponentUpdate
  * to create a copy which will contain the resulting merged update.
  *
  * 'update' will be empty after this operation, so ensure to call
  * Schema_DestroyComponentUpdate(update) to avoid leaking memory.
  *
  * Returns 1 if success, 0 if there was a failure. Call
  * `Schema_GetError(Schema_GetComponentUpdateFields(target_update))` to get the error message.
  */
uint8_t Schema_MergeComponentUpdateIntoUpdate(Schema_ComponentUpdate* update,Schema_ComponentUpdate* target_update)
 {
  return 0;
 }
 /**
  * Takes an at-rest component data object 'data', and converts it into a component update with all
  * fields set. The resulting component update has the property that if applied to a component data
  * object, it is guaranteed to result in the original at-rest component data object 'data'. Any
  * fields contained in 'data' which are not present in the component definition will be dropped.
  *
  * This operation requires a component definition to be provided at runtime in a schema bundle. See
  * `Schema_Bundle_Load` for more information.
  *
  * If successful, 'data' will become empty after this operation. Otherwise, 'data' will be left in a
  * valid but unspecified state. After calling this function, we recommend immediately calling
  * Schema_DestroyComponentData(data) to avoid leaking memory.
  *
  * A new component update object will be returned to the caller on success, otherwise NULL will be
  * returned on failure.
  *
  * An error callback can be optionally provided to get more information as to why the operation
  * failed. 'callback_user_data' is an arbitrary value that will be passed to the callback. If
  * unused, or no error callback is specified, this parameter can be set to NULL.
  */
Schema_ComponentUpdate* Schema_ConvertComponentDataIntoUpdate(const Schema_Bundle* bundle, Schema_ComponentId component_id,Schema_ComponentData* data, void* callback_user_data,Schema_ErrorCallback* error_callback)
 {
  return nullptr;
 }

 /** Completely clears all fields in the given object. */
void Schema_Clear(Schema_Object* object)
 {
  
 }
 /** Completely clears the given field ID in the given object. */
void Schema_ClearField(Schema_Object* object, Schema_FieldId field_id)
 {
  
 }
 /**
  * Copies all fields from `src` to `dst`. The copy is shallow; changes made to object fields in the
  * source will also be reflected in the copied fields.
  *
  * If `src == dst`, or if the objects are not associated with the same root schema type instance, no
  * operation is performed.
  */
void Schema_ShallowCopy(const Schema_Object* src, Schema_Object* dst)
 {
  
 }
 /**
  * Copies over a field from `src` to `dst`. If multiple fields with the given field_id exist all
  * are copied. The copy is shallow; changes made to object fields in the source will also be
  * reflected in the copied fields.
  *
  * If `src == dst`, or if the objects are not associated with the same root schema type instance, no
  * operation is performed.
  */
void Schema_ShallowCopyField(const Schema_Object* src, Schema_Object* dst,Schema_FieldId field_id)
 {
  
 }

 
 
 /**
  * Merges the given buffer into the given object, appending all fields. This function
  * can fail; if the return value is zero, call Schema_GetError to obtain an error string.
  *
  * Note: the provided buffer is not copied, and must live as long as the root schema type instance.
  */
uint8_t Schema_MergeFromBuffer(Schema_Object* object, const uint8_t* buffer,uint32_t length)
 {
  return 0;
 }
 /** Computes the serialized length of the given Schema_Object. */
uint32_t Schema_GetWriteBufferLength(const Schema_Object* object)
 {
  return 0;
 }
 /**
  * Serializes the given object into the provided buffer, which _must_ have space at
  * least equal to the length returned by Schema_WriteBufferLength. This function can
  * fail; if the return value is zero, call Schema_GetError to obtain an error string.
  *
  * `length` must equal the value returned by `Schema_GetWriteBufferLength`. Otherwise, the behavior
  * is undefined.
  */
uint8_t Schema_SerializeToBuffer(const Schema_Object* object, uint8_t* buffer,uint32_t length)
 {
  return 0;
 }

 /**
  * Obtains the most recent error encountered by any object associated with the given object. The
  * buffer is owned by the schema object that manages the memory of `object`, and may get replaced
  * after calling another Schema function. Returns `NULL` if no error has occurred within the given
  * object.
  */
const char* Schema_GetError(const Schema_Object* object)
 {
  return nullptr;
 }
 /** Returns the number of unique field IDs used in the Schema_Object. */
uint32_t Schema_GetUniqueFieldIdCount(const Schema_Object* object)
 {
  return 0;
 }
 /**
  * Returns the sorted list of unique field IDs used in the Schema_Object. The buffer parameter
  * must have space remaining for as many field IDs as indicated by Schema_GetUniqueFieldIdCount.
  */
void Schema_GetUniqueFieldIds(const Schema_Object* object, uint32_t* buffer)
 {
  
 }

 /* Functions that append a single value to the set of fields present in an object. For any field ID,
  * these can be called repeatedly to construct a list of values, or mixed freely with the AddList
  * functions below; however, making a single call to an AddList function is the most efficient way
  * to construct a list of values. Note that, for best performance, fields should be added to the
  * object in field ID order. */
void Schema_AddFloat(Schema_Object* object, Schema_FieldId field_id, float value)
 {
   protobuf_msg* msg = (protobuf_msg*)object;
   msg->set_float(field_id,value);
 }

void Schema_AddDouble(Schema_Object* object, Schema_FieldId field_id, double value)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  msg->set_double(field_id,value);
 }

void Schema_AddBool(Schema_Object* object, Schema_FieldId field_id, uint8_t value)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  msg->set_boolean(field_id,value);
 }

void Schema_AddInt32(Schema_Object* object, Schema_FieldId field_id, int32_t value)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  msg->set_int32(field_id,value);
 }

void Schema_AddInt64(Schema_Object* object, Schema_FieldId field_id, int64_t value)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  msg->set_int64(field_id,value);
 }

void Schema_AddUint32(Schema_Object* object, Schema_FieldId field_id, uint32_t value)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  msg->set_uint32(field_id,value);
 }

void Schema_AddUint64(Schema_Object* object, Schema_FieldId field_id, uint64_t value)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  msg->set_uint64(field_id,value);
 }
 
void Schema_AddEntityId(Schema_Object* object, Schema_FieldId field_id,Schema_EntityId value)
 {
    Schema_AddInt64(object,field_id,value);
 }

void Schema_AddEnum(Schema_Object* object, Schema_FieldId field_id, uint32_t value)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  msg->set_enum(field_id,value);
 }

void Schema_AddBytes(Schema_Object* object, Schema_FieldId field_id,const uint8_t* buffer, uint32_t length)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  std::string blob((const char*)buffer,length);
  msg->set_blob(field_id,blob);
 }

Schema_Object* Schema_AddObject(Schema_Object* object, Schema_FieldId field_id)
 {
    protobuf_msg* msg = (protobuf_msg*)object;
    auto field_info =  msg->get_field_info_by_tag(field_id);
    auto factory  = dynamic_msg_mgr::getMe().get_factory();
    auto field_msg = factory->new_message_by_name(field_info.fully_qualified_type.c_str());
    msg->set_message(field_id,*field_msg);
    return  (Schema_Object*)msg->mutable_message(field_id).get();
 }

 /* Functions that append a list of primitive values for a particular field ID to an object. Note
  * that, for best performance, fields should be added to the object in field ID order.
  *
  * Note: no copy of the data is made. The source data must live as long as the root schema type
  * instance. */
void Schema_AddFloatList(Schema_Object* object, Schema_FieldId field_id,const float* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
    msg->set_repeated_float(field_id,values[i],i);
 }

void Schema_AddDoubleList(Schema_Object* object, Schema_FieldId field_id,const double* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_double(field_id,values[i],i);
 }

void Schema_AddBoolList(Schema_Object* object, Schema_FieldId field_id,const uint8_t* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_boolean(field_id,values[i],i);
 }

void Schema_AddInt32List(Schema_Object* object, Schema_FieldId field_id,const int32_t* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_int32(field_id,values[i],i);
 }

void Schema_AddInt64List(Schema_Object* object, Schema_FieldId field_id,const int64_t* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_int64(field_id,values[i],i);
 }

void Schema_AddUint32List(Schema_Object* object, Schema_FieldId field_id,const uint32_t* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_uint32(field_id,values[i],i);
 }

void Schema_AddUint64List(Schema_Object* object, Schema_FieldId field_id,const uint64_t* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_uint64(field_id,values[i],i);
 }

void Schema_AddEntityIdList(Schema_Object* object, Schema_FieldId field_id,const Schema_EntityId* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_int64(field_id,values[i],i);
 }
void Schema_AddEnumList(Schema_Object* object, Schema_FieldId field_id,const uint32_t* values, uint32_t count)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  for(int i=0; i<count; i++)
   msg->set_repeated_enum(field_id,(int32_t)values[i],i);
 }

 /* Functions that determine the number of occurrences of a particular field ID in an object.
  *
  * Note that, for best performance, fields should be accessed in field ID order. */
 uint32_t Schema_GetFloatCount(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_float_count(field_id);
 }

 uint32_t Schema_GetDoubleCount(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_double_count(field_id);
 }

 uint32_t Schema_GetBoolCount(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_boolean_count(field_id);
 }

 uint32_t Schema_GetInt32Count(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_int32_count(field_id);
 }

 uint32_t Schema_GetInt64Count(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_int64_count(field_id);
 }

 uint32_t Schema_GetUint32Count(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_uint32_count(field_id);
 }

 uint32_t Schema_GetUint64Count(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_uint64_count(field_id);
 }
 
 uint32_t Schema_GetEntityIdCount(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_int64_count(field_id);
 }

 uint32_t Schema_GetEnumCount(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_enum_count(field_id);
 }

 uint32_t Schema_GetBytesCount(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_blob_count(field_id);
 }

 uint32_t Schema_GetObjectCount(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_message_count(field_id);
 }

 /* Functions that access a single value for a particular field ID in an object. Boolean values are
  * guaranteed to be either 0 or 1. These functions assume the field is non-repeated, i.e. if the
  * field appears multiple times in the object, only the last field will be accessed (equivalent to
  * `Schema_Index*(object, field_id, Schema_Get*Count(object, field_id) - 1)`).
  *
  * If the field does not exist, a default value is returned; call the corresponding GetCount
  * function above to determine if the field is present.
  *
  * Note that, for best performance, fields should be accessed in field ID order. */
 float Schema_GetFloat(const Schema_Object* object, Schema_FieldId field_id)
 {
   protobuf_msg* msg = (protobuf_msg*)object;
   return msg->get_float(field_id);
 }

 double Schema_GetDouble(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_double(field_id);
 }

 uint8_t Schema_GetBool(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_boolean(field_id);
 }

 int32_t Schema_GetInt32(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_int32(field_id);
 }

 int64_t Schema_GetInt64(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_int64(field_id);
 }
 uint32_t Schema_GetUint32(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_uint32(field_id);
 }

 uint64_t Schema_GetUint64(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_uint64(field_id);
 }

 Schema_EntityId Schema_GetEntityId(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_int64(field_id);
 }

 uint32_t Schema_GetEnum(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_enum(field_id);
 }

 uint32_t Schema_GetBytesLength(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_blob(field_id).length();
 }

 const uint8_t* Schema_GetBytes(const Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return (uint8_t*)msg->get_blob(field_id).data();
 }

 Schema_Object* Schema_GetObject(Schema_Object* object, Schema_FieldId field_id)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return ( Schema_Object*)msg->get_message(field_id).get();
 }

 /* Functions that access a value by index for a particular field ID in an object. Boolean values are
  * guaranteed to be either 0 or 1.
  *
  * If the index doesn't exist for the given field, a default is returned; call
  * the corresponding GetCount function above to to determine if the total number of fields.
  *
  * Note that, for best performance, fields should be accessed in field ID and index order. */
float Schema_IndexFloat(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_float(field_id,index);
 }

double Schema_IndexDouble(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_double(field_id,index);
 }

uint8_t Schema_IndexBool(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_boolean(field_id,index);
 }

int32_t Schema_IndexInt32(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_int32(field_id,index);
 }

int64_t Schema_IndexInt64(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_int64(field_id,index);
 }

uint32_t Schema_IndexUint32(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_uint32(field_id,index);
 }

uint64_t Schema_IndexUint64(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_uint64(field_id,index);
 }

Schema_EntityId Schema_IndexEntityId(const Schema_Object* object,Schema_FieldId field_id, uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_int64(field_id,index);
 }

uint32_t Schema_IndexEnum(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_enum(field_id,index);
 }

uint32_t Schema_IndexBytesLength(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return msg->get_repeated_blob(field_id,index).length();
 }

const uint8_t* Schema_IndexBytes(const Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return (uint8_t*)msg->get_repeated_blob(field_id,index).data();
 }

Schema_Object* Schema_IndexObject(Schema_Object* object, Schema_FieldId field_id,uint32_t index)
 {
  protobuf_msg* msg = (protobuf_msg*)object;
  return (Schema_Object*)msg->get_repeated_message(field_id,index).get();
 }

 

 /** Free the resources associated with a Schema_Json instance. */
 void Schema_Json_Destroy(Schema_Json* json){}
 /**
  * Get a null-terminated JSON string from a Schema_Json instance.
  *
  * The returned pointer will be valid until the source Schema_Json object is destroyed with
  * Schema_Json_Destroy.
  */
 const char* Schema_Json_GetJsonString(const Schema_Json* json){return nullptr;}
 /**
  * Get a null-terminated string containing the last set of errors that occurred while performing
  * JSON operations. If multiple errors occur, they will be separated by a newline (\n).
  * Returns NULL if no error occurred.
  *
  * The returned pointer will remain valid until another Schema_Json_* function (with the exception
  * Schema_Json_GetLastWarning) is called from the same thread.
  */
const char* Schema_Json_GetLastError(void){return nullptr;}
 /**
  * Get a null-terminated string containing the last warning that occurred while performing JSON
  * operations. If multiple warnings occur, they will be separated by a newline (\n).
  * Returns NULL if no warning occurred.
  *
  * The returned pointer will remain valid until another Schema_Json_* function (with the exception
  * Schema_Json_GetLastError) is called from the same thread.
  */
const char* Schema_Json_GetLastWarning(void){return nullptr;}

 /**
  * Loads a Schema_Object from the provided null-terminated JSON string given the provided schema
  * bundle and qualified type name.
  *
  * Returns 1 if no error occurred.
  * Returns 0 if there was a failure to read any data from the JSON; use Schema_Json_GetLastError
  * to get a string description of the error that occurred.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
 uint8_t Schema_Json_LoadObject(const Schema_Bundle* bundle,
                                           const char* qualified_type_name, const char* json_string,
                                           Schema_Object* object)
 {
  return 0;
 }
 /**
  * Dumps the given Schema_Object instance into a Schema_Json using the provided bundle and
  * qualified type name.
  *
  * It is the caller's responsibility to free the returned Schema_Json* by calling
  * Schema_Json_Destroy.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_Json* Schema_Json_DumpObject(const Schema_Bundle* bundle,
                                                const char* qualified_type_name,
                                                Schema_Object* object)
 {
  return nullptr;
 }

 /**
  * Loads a Schema_ComponentData from the provided JSON string given the provided schema bundle and
  * component ID.
  *
  * It is the caller's responsibility to free the returned Schema_ComponentData* by calling
  * Schema_DestroyComponentData.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
 Schema_ComponentData* Schema_Json_LoadComponentData(const Schema_Bundle* bundle,
                                                                Schema_ComponentId component_id,
                                                                const char* json_string)
 {
  return nullptr;
 }
 /**
  * Dumps the given Schema_ComponentData instance into a Schema_Json using the provided
  * bundle and component ID.
  *
  * It is the caller's responsibility to free the returned Schema_Json* by calling
  * Schema_Json_Destroy.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_Json* Schema_Json_DumpComponentData(const Schema_Bundle* bundle,
                                                       Schema_ComponentId component_id,
                                                       Schema_ComponentData* data)
 {
  return  nullptr;
 }
 /**
  * Loads a Schema_ComponentUpdate from the provided JSON string given the provided schema bundle and
  * component ID.
  *
  * It is the caller's responsibility to free the returned Schema_ComponentUpdate* by calling
  * Schema_DestroyComponentUpdate.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_ComponentUpdate* Schema_Json_LoadComponentUpdate(const Schema_Bundle* bundle,
                                                                    Schema_ComponentId component_id,
                                                                    const char* json_string)
 {
  return nullptr;
 }
 /**
  * Dumps the given Schema_ComponentUpdate instance into a Schema_Json using the provided
  * bundle and component ID.
  *
  * It is the caller's responsibility to free the returned Schema_Json* by calling
  * Schema_Json_Destroy.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_Json* Schema_Json_DumpComponentUpdate(const Schema_Bundle* bundle,
                                                         Schema_ComponentId component_id,
                                                         Schema_ComponentUpdate* update)
 {
  return nullptr;
 }
 /**
  * Loads a Schema_CommandRequest from the provided JSON string given the provided schema bundle and
  * component ID.
  *
  * It is the caller's responsibility to free the returned Schema_CommandRequest* by calling
  * Schema_DestroyCommandRequest.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_CommandRequest* Schema_Json_LoadCommandRequest(const Schema_Bundle* bundle,
                                                                  Schema_ComponentId component_id,
                                                                  Schema_FieldId command_index,
                                                                  const char* json_string)
 {
  return nullptr;
 }
 /**
  * Dumps the given Schema_CommandRequest instance into a Schema_Json using the provided schema
  * bundle, component ID and command index.
  *
  * It is the caller's responsibility to free the returned Schema_Json* by calling
  * Schema_Json_Destroy.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_Json* Schema_Json_DumpCommandRequest(const Schema_Bundle* bundle,
                                                        Schema_ComponentId component_id,
                                                        Schema_FieldId command_index,
                                                        Schema_CommandRequest* request)
 {
  return nullptr;
 }
 /**
  * Loads a Schema_CommandResponse from the provided JSON string given the provided bundle, component
  * ID, and command index.
  *
  * It is the caller's responsibility to free the returned Schema_CommandResponse* by calling
  * Schema_DestroyCommandResponse.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_CommandResponse* Schema_Json_LoadCommandResponse(const Schema_Bundle* bundle,
                                                                    Schema_ComponentId component_id,
                                                                    Schema_FieldId command_index,
                                                                    const char* json_string)
 {
  return nullptr;
 }
 /**
  * Dumps the given Schema_CommandResponse instance into a Schema_Json using the provided
  * schema bundle, component ID and command index.
  *
  * It is the caller's responsibility to free the returned Schema_Json* by calling
  * Schema_Json_Destroy.
  *
  * Note: Returns NULL if an error occurred. Use Schema_Json_GetLastError to get a string
  * description of the error that occurred during this operation.
  *
  * Note: Warnings may also be generated in some cases. Use Schema_Json_GetLastWarning to get a
  * string description of any warning that occurred during this operation.
  */
Schema_Json* Schema_Json_DumpCommandResponse(const Schema_Bundle* bundle,
                                                         Schema_ComponentId component_id,
                                                         Schema_FieldId command_index,
                                                         Schema_CommandResponse* response)
 {
  return nullptr;
 }
